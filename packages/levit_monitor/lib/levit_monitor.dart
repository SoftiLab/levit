library levit_monitor;

import 'package:levit_dart/levit_dart.dart';

import 'src/core/event.dart';
import 'src/core/transport.dart';
import 'src/middlewares/state.dart';
import 'src/transports/console_transport.dart';

export 'src/core/event.dart';
export 'src/core/transport.dart';
export 'src/transports/console_transport.dart';
export 'src/transports/file_transport.dart';
export 'src/transports/websocket_transport.dart';

/// The authoritative entry point for application monitoring and diagnostics.
///
/// [LevitMonitor] acts as a unified hub that collects events from both the
/// dependency injection system ([Levit]) and the reactive state engine ([Lx]).
/// It processes these events through a filtering pipeline and dispatches them
/// to a [LevitTransport] for inspection or storage.
///
/// ### Core Capabilities
/// 1.  **Unified Observability**: Bridges DI events (registration, resolution)
///     and reactive events (state mutations, graph changes) into a single path.
/// 2.  **Extensible Transports**: Supports pluggable destinations like the
///     console, local files, or WebSockets for external DevTools.
/// 3.  **Predicate Filtering**: Provides a global filter to suppress noisy
///     events or focus on specific diagnostic areas.
class LevitMonitor {
  static LevitMonitorMiddleware? _middleware;

  /// The active predicate used to filter outgoing events.
  static bool Function(MonitorEvent event)? _filter;

  /// Returns the current event filter, if any.
  static bool Function(MonitorEvent event)? get filter => _filter;

  /// Configures a global filter to selectively process monitor events.
  ///
  /// The [filter] function receives every [MonitorEvent] generated by the
  /// system. Returning `true` allows the event to proceed to the transport.
  ///
  /// ### Examples
  /// ```dart
  /// // Exclude specific reactive variables by name
  /// LevitMonitor.setFilter((e) => e is! ReactiveEvent || e.reactive.name != 'secret');
  ///
  /// // Only monitor Dependency Injection events
  /// LevitMonitor.setFilter((e) => e is DependencyEvent);
  /// ```
  static void setFilter(bool Function(MonitorEvent event)? filter) {
    _filter = filter;
  }

  /// Evaluates whether a specific [event] should be processed based on the
  /// current filter configuration.
  static bool shouldProcess(MonitorEvent event) {
    return _filter == null || _filter!(event);
  }

  /// Bootstraps the monitoring system and attaches it to the application.
  ///
  /// By default, [LevitMonitor] uses a [ConsoleTransport] which pipes JSON-encoded
  /// events to standard output.
  ///
  /// *   [transport]: An optional destination for monitor events.
  static void attach({LevitTransport? transport}) {
    detach(); // Ensure an idempotent state

    // Ensure auto-linking is enabled to capture ID generation and owner associations
    Levit.enableAutoLinking();

    final t = transport ?? ConsoleTransport();

    _middleware = LevitMonitorMiddleware(transport: t);
    _middleware?.enable();
  }

  /// Detaches the monitor from the application and releases associated resources.
  static void detach() {
    _middleware?.disable();
    _middleware = null;
  }
}
